{
  "_args": [
    [
      {
        "raw": "typedi",
        "scope": null,
        "escapedName": "typedi",
        "name": "typedi",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/home/roni/Documents/backend/login-backend"
    ]
  ],
  "_from": "typedi@latest",
  "_id": "typedi@0.7.2",
  "_inCache": true,
  "_location": "/typedi",
  "_nodeVersion": "9.5.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/typedi_0.7.2_1522133556097_0.14019550210647735"
  },
  "_npmUser": {
    "name": "pleerock",
    "email": "zarrhost@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "typedi",
    "scope": null,
    "escapedName": "typedi",
    "name": "typedi",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/typedi/-/typedi-0.7.2.tgz",
  "_shasum": "fcd66209fc57e8f62373a7fa0a3f34b24e9b03ed",
  "_shrinkwrap": null,
  "_spec": "typedi",
  "_where": "/home/roni/Documents/backend/login-backend",
  "author": {
    "name": "Umed Khudoiberdiev",
    "email": "pleerock.me@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/pleerock/typedi/issues"
  },
  "dependencies": {},
  "description": "Dependency injection for TypeScript",
  "devDependencies": {
    "@types/chai": "^4.0.5",
    "@types/mocha": "^2.2.44",
    "@types/node": "^8.0.53",
    "@types/sinon": "^4.0.0",
    "chai": "^4.1.2",
    "del": "^3.0.0",
    "gulp": "^3.9.1",
    "gulp-mocha": "^3.0.1",
    "gulp-replace": "^0.6.1",
    "gulp-shell": "^0.6.3",
    "gulp-sourcemaps": "^2.6.1",
    "gulp-tslint": "^8.1.2",
    "gulp-typescript": "^3.2.3",
    "gulpclass": "^0.1.2",
    "mocha": "^3.2.0",
    "reflect-metadata": "^0.1.10",
    "sinon": "^4.1.2",
    "sinon-chai": "^2.14.0",
    "ts-node": "^3.3.0",
    "tslint": "^5.8.0",
    "tslint-stylish": "^2.1.0",
    "typescript": "^2.6.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-0hmr49V2B2TLcuwaj6klnhG9QKKXUp9ensCUlJUAWsPX551WMsBDvwVW60kHJ6vzs04iexbGuPhHBmW6XEjkyg==",
    "shasum": "fcd66209fc57e8f62373a7fa0a3f34b24e9b03ed",
    "tarball": "https://registry.npmjs.org/typedi/-/typedi-0.7.2.tgz",
    "fileCount": 47,
    "unpackedSize": 104152
  },
  "homepage": "https://github.com/pleerock/typedi#readme",
  "license": "MIT",
  "maintainers": [
    {
      "name": "pleerock",
      "email": "zarrhost@gmail.com"
    }
  ],
  "name": "typedi",
  "optionalDependencies": {},
  "private": false,
  "readme": "# TypeDI\r\n\r\n[![Build Status](https://travis-ci.org/typestack/typedi.svg?branch=master)](https://travis-ci.org/typestack/typedi)\r\n[![npm version](https://badge.fury.io/js/typedi.svg)](https://badge.fury.io/js/typedi)\r\n[![Dependency Status](https://david-dm.org/typestack/typedi.svg)](https://david-dm.org/typestack/typedi)\r\n[![Join the chat at https://gitter.im/typestack/typedi](https://badges.gitter.im/typestack/typedi.svg)](https://gitter.im/typestack/typedi?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nTypeDI is a [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) tool for JavaScript and TypeScript.\r\nUsing TypeDI you can build well-structured and easily tested applications.\r\n\r\n* [Usage with JavaScript](#usage-with-javascript)\r\n* [Usage with TypeScript](#usage-with-typescript)\r\n\r\n## Usage with JavaScript\r\n\r\nInstall the module:\r\n\r\n`npm install typedi --save`\r\n\r\nNow you can use TypeDI.\r\nThe most simple usage example is:\r\n\r\n```javascript\r\nclass SomeClass {\r\n\r\n    someMethod() {\r\n    }\r\n\r\n}\r\n\r\nvar Container = require(\"typedi\").Container;\r\nvar someClass = Container.get(SomeClass);\r\nsomeClass.someMethod();\r\n```\r\n\r\nThen you can call `Container.get(SomeClass)` from anywhere in your application\r\n and you'll always have the same instance of `SomeClass`.\r\n\r\nIn your class's constructor you always recieve as a last argument a container which you can use to get other dependencies.\r\n\r\n```javascript\r\nclass BeanFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass SugarFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass WaterFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass CoffeeMaker {\r\n\r\n    constructor(container) {\r\n        this.beanFactory = container.get(BeanFactory);\r\n        this.beanFactory = container.get(SugarFactory);\r\n        this.beanFactory = container.get(WaterFactory);\r\n    }\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nvar Container = require(\"typedi\").Container;\r\nvar coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n```\r\n\r\nWith TypeDI you can use a named services. Example:\r\n\r\n```javascript\r\nvar Container = require(\"typedi\").Container;\r\n\r\nclass BeanFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass SugarFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass WaterFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\nclass CoffeeMaker {\r\n\r\n    beanFactory: Factory;\r\n    sugarFactory: Factory;\r\n    waterFactory: Factory;\r\n\r\n    constructor(container) {\r\n        this.beanFactory = container.get(\"bean.factory\");\r\n        this.sugarFactory = container.get(\"sugar.factory\");\r\n        this.waterFactory = container.get(\"water.factory\");\r\n    }\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nContainer.set(\"bean.factory\", new BeanFactory(Container));\r\nContainer.set(\"sugar.factory\", new SugarFactory(Container));\r\nContainer.set(\"water.factory\", new WaterFactory(Container));\r\nContainer.set(\"coffee.maker\", new CoffeeMaker(Container));\r\n\r\nvar coffeeMaker = Container.get(\"coffee.maker\");\r\ncoffeeMaker.make();\r\n```\r\n\r\nThis feature especially useful if you want to store (and inject later on) some settings or configuration options.\r\nFor example:\r\n\r\n```javascript\r\nvar Container = require(\"typedi\").Container;\r\n\r\n// somewhere in your global app parameters\r\nContainer.set(\"authorization-token\", \"RVT9rVjSVN\");\r\n\r\nclass UserRepository {\r\n\r\n    constructor(container) {\r\n        this.authorizationToken = container.get(\"authorization-token\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nWhen you write tests you can easily provide your own \"fake\" dependencies to classes you are testing using `set` method:\r\n\r\n```javascript\r\nContainer.set(CoffeeMaker, new FakeCoffeeMaker());\r\n\r\n// or for named services\r\n\r\nContainer.set([\r\n    { id: \"bean.factory\", value: new FakeBeanFactory() },\r\n    { id: \"sugar.factory\", value: new FakeSugarFactory() },\r\n    { id: \"water.factory\", value: new FakeWaterFactory() }\r\n]);\r\n```\r\n\r\n## Usage with TypeScript\r\n\r\n1. Install module:\r\n\r\n    `npm install typedi --save`\r\n\r\n2. Install [reflect-metadata](https://www.npmjs.com/package/reflect-metadata) package:\r\n\r\n    `npm install reflect-metadata --save`\r\n\r\n    and import it somewhere in the global place of your app before any service declaration or import (for example in `app.ts`):\r\n\r\n    `import \"reflect-metadata\";`\r\n\r\n3. You may need to install node typings:\r\n\r\n    `npm install @types/node --save`\r\n\r\n\r\n4. Enabled following settings in `tsconfig.json`:\r\n\r\n```json\r\n\"emitDecoratorMetadata\": true,\r\n\"experimentalDecorators\": true,\r\n```\r\n\r\nNow you can use TypeDI.\r\nThe most simple usage example is:\r\n\r\n```javascript\r\nimport \"reflect-metadata\";\r\nimport {Service, Container} from \"typedi\";\r\n\r\n@Service()\r\nclass SomeClass {\r\n\r\n    someMethod() {\r\n    }\r\n\r\n}\r\n\r\nlet someClass = Container.get(SomeClass);\r\nsomeClass.someMethod();\r\n```\r\n\r\nThen you can call `Container.get(SomeClass)` from anywhere in your application\r\n and you'll always have the same instance of `SomeClass`.\r\n\r\nYou can use **property injection** and inject services into your class using `@Inject` decorator:\r\n\r\n```javascript\r\nimport {Container, Inject, Service} from \"typedi\";\r\n\r\n@Service()\r\nclass BeanFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass SugarFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass WaterFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass CoffeeMaker {\r\n\r\n    @Inject()\r\n    beanFactory: BeanFactory;\r\n    \r\n    @Inject()\r\n    sugarFactory: SugarFactory;\r\n    \r\n    @Inject()\r\n    waterFactory: WaterFactory;\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n```\r\n\r\nYou can also use a constructor injection:\r\n\r\n```javascript\r\nimport {Container, Service} from \"typedi\";\r\n\r\n@Service()\r\nclass BeanFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass SugarFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass WaterFactory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nclass CoffeeMaker {\r\n\r\n    constructor(private beanFactory: BeanFactory,\r\n                private sugarFactory: SugarFactory,\r\n                private waterFactory: WaterFactory) {}\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n```\r\n\r\nWith TypeDI you can use a named services. Example:\r\n\r\n```javascript\r\nimport {Container, Service, Inject} from \"typedi\";\r\n\r\ninterface Factory {\r\n    create(): void;\r\n}\r\n\r\n@Service(\"bean.factory\")\r\nclass BeanFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service(\"sugar.factory\")\r\nclass SugarFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service(\"water.factory\")\r\nclass WaterFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service(\"coffee.maker\")\r\nclass CoffeeMaker {\r\n\r\n    beanFactory: Factory;\r\n    sugarFactory: Factory;\r\n\r\n    @Inject(\"water.factory\")\r\n    waterFactory: Factory;\r\n\r\n    constructor(@Inject(\"bean.factory\") beanFactory: BeanFactory,\r\n                @Inject(\"sugar.factory\") sugarFactory: SugarFactory) {\r\n        this.beanFactory = beanFactory;\r\n        this.sugarFactory = sugarFactory;\r\n    }\r\n\r\n    make() {\r\n        this.beanFactory.create();\r\n        this.sugarFactory.create();\r\n        this.waterFactory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get<CoffeeMaker>(\"coffee.maker\");\r\ncoffeeMaker.make();\r\n```\r\n\r\nThis feature especially useful if you want to store (and inject later on) some settings or configuration options.\r\nFor example:\r\n\r\n```javascript\r\nimport {Container, Service, Inject} from \"typedi\";\r\n\r\n// somewhere in your global app parameters\r\nContainer.set(\"authorization-token\", \"RVT9rVjSVN\");\r\n\r\n@Service()\r\nclass UserRepository {\r\n\r\n    @Inject(\"authorization-token\")\r\n    authorizationToken: string;\r\n\r\n}\r\n```\r\n\r\nWhen you write tests you can easily provide your own \"fake\" dependencies to classes you are testing using `set` method:\r\n`provide` methods of the container:\r\n\r\n```javascript\r\nContainer.set(CoffeeMaker, new FakeCoffeeMaker());\r\n\r\n// or for named services\r\n\r\nContainer.set([\r\n    { id: \"bean.factory\", value: new FakeBeanFactory() },\r\n    { id: \"sugar.factory\", value: new FakeSugarFactory() },\r\n    { id: \"water.factory\", value: new FakeWaterFactory() }\r\n]);\r\n```\r\n\r\n## TypeScript Advanced Usage Examples\r\n\r\n* [Services with token name](#services-with-token-name) \r\n* [Using factory function to create service](#using-factory-function-to-create-service) \r\n* [Using factory class to create service](#using-factory-class-to-create-service)\r\n* [Problem with circular references](#problem-with-circular-references) \r\n* [Inherited injections](#inherited-injections) \r\n* [Custom decorators](#custom-decorators) \r\n* [Using service groups](#using-service-groups) \r\n* [Using multiple containers and scoped containers](#using-multiple-containers-and-scoped-containers) \r\n* [Remove registered services or reset container state](#remove-registered-services-or-reset-container-state) \r\n\r\n### Services with token name\r\n\r\nYou can use a services with a `Token` instead of name or target class. \r\nIn this case you can use type safe interface-based services.\r\n\r\n```javascript\r\nimport {Container, Service, Inject, Token} from \"typedi\";\r\n\r\nexport interface Factory {\r\n    create(): void;\r\n}\r\n\r\nexport const FactoryService = new Token<Factory>(); \r\n\r\n@Service(FactoryService)\r\nexport class BeanFactory implements Factory {\r\n    create() {\r\n    }\r\n}\r\n\r\n@Service()\r\nexport class CoffeeMaker {\r\n    \r\n    private factory: Factory;\r\n\r\n    constructor(@Inject(type => FactoryService) factory: Factory) {\r\n        this.factory = factory;\r\n    }\r\n\r\n    make() {\r\n        this.factory.create();\r\n    }\r\n\r\n}\r\n\r\nlet coffeeMaker = Container.get(CoffeeMaker);\r\ncoffeeMaker.make();\r\n\r\nlet factory = Container.get(FactoryService); // factory is instance of Factory\r\nfactory.create();\r\n```\r\n\r\n### Using factory function to create service\r\n\r\nYou can create your services with the container using factory functions.\r\n\r\nThis way, service instance will be created by calling your factory function instead of\r\ninstantiating a class directly.\r\n\r\n```javascript\r\nimport {Container, Service} from \"typedi\";\r\n\r\nfunction createCar() {\r\n    return new Car(\"V8\");\r\n}\r\n\r\n@Service({ factory: createCar })\r\nclass Car {\r\n    constructor (public engineType: string) {\r\n    }\r\n}\r\n\r\n// Getting service from the container.\r\n// Service will be created by calling the specified factory function.\r\nconst car = Container.get(Car);\r\n\r\nconsole.log(car.engineType); // > \"V8\"\r\n```\r\n\r\n### Using factory class to create service\r\n\r\nYou can also create your services using factory classes.\r\n\r\nThis way, service instance will be created by calling given factory service's method factory instead of\r\ninstantiating a class directly.\r\n\r\n```javascript\r\nimport {Container, Service} from \"typedi\";\r\n\r\n@Service()\r\nclass CarFactory {\r\n    \r\n    constructor(public logger: LoggerService) {\r\n    }\r\n    \r\n    create() {\r\n        return new Car(\"BMW\", this.logger);\r\n    }\r\n    \r\n}\r\n\r\n@Service({ factory: [CarFactory, \"create\"] })\r\nclass Car {\r\n    constructor(public model: string, public logger: LoggerInterface) {\r\n    }\r\n}\r\n```\r\n\r\n### Problem with circular references\r\n\r\nThere is a known issue in language that it can't handle circular references. For example:\r\n\r\n```javascript\r\n// Car.ts\r\n@Service()\r\nexport class Car {\r\n    @Inject()\r\n    engine: Engine;\r\n}\r\n\r\n// Engine.ts\r\n@Service()\r\nexport class Engine {\r\n    @Inject()\r\n    car: Car;\r\n}\r\n```\r\n\r\nThis code will not work, because Engine has a reference to Car, and Car has a reference to Engine.\r\nOne of them will be undefined and it cause errors. To fix them you need to specify a type in a function this way:\r\n\r\n```javascript\r\n// Car.ts\r\n@Service()\r\nexport class Car {\r\n    @Inject(type => Engine)\r\n    engine: Engine;\r\n}\r\n\r\n// Engine.ts\r\n@Service()\r\nexport class Engine {\r\n    @Inject(type => Car)\r\n    car: Car;\r\n}\r\n```\r\n\r\nAnd that's all. Same for constructor injections.\r\n\r\n### Inherited injections\r\n\r\nInherited injections are supported as well. In order to use them you must mark inherited class as a @Service.\r\nFor example:\r\n\r\n```javascript\r\n// Car.ts\r\n@Service()\r\nexport abstract class Car {\r\n\r\n    @Inject()\r\n    engine: Engine;\r\n\r\n}\r\n\r\n// Engine.ts\r\n@Service()\r\nexport class Bus extends Car {\r\n\r\n    // you can call this.engine in this class\r\n}\r\n```\r\n\r\n### Custom decorators\r\n\r\nYou can create your own decorators which will inject your given values for your service dependencies.\r\nFor example:\r\n\r\n```javascript\r\n// Logger.ts\r\nexport function Logger() {\r\n    return function(object: Object, propertyName: string, index?: number) {\r\n        const logger = new ConsoleLogger();\r\n        Container.registerHandler({ object, propertyName, index, value: containerInstance => logger });\r\n    };\r\n}\r\n\r\n// LoggerInterface.ts\r\nexport interface LoggerInterface {\r\n\r\n    log(message: string): void;\r\n\r\n}\r\n\r\n// ConsoleLogger.ts\r\nimport {LoggerInterface} from \"./LoggerInterface\";\r\n\r\nexport class ConsoleLogger implements LoggerInterface {\r\n\r\n    log(message: string) {\r\n        console.log(message);\r\n    }\r\n\r\n}\r\n\r\n// UserRepository.ts\r\n@Service()\r\nexport class UserRepository {\r\n\r\n    constructor(@Logger() private logger: LoggerInterface) {\r\n    }\r\n\r\n    save(user: User) {\r\n        this.logger.log(`user ${user.firstName} ${user.secondName} has been saved.`);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### Using service groups\r\n\r\nYou can group multiple services into single group tagged with service id or token.\r\nFor example:\r\n\r\n```javascript\r\n// Factory.ts\r\nexport interface Factory {\r\n    create(): any;\r\n}\r\n\r\n// FactoryToken.ts\r\nexport const FactoryToken = new Token<Factory>(\"factories\");\r\n\r\n// BeanFactory.ts\r\n@Service({ id: FactoryToken, multiple: true })\r\nexport class BeanFactory implements Factory {\r\n\r\n    create() {\r\n        console.log(\"bean created\");\r\n    }\r\n\r\n}\r\n\r\n// SugarFactory.ts\r\n@Service({ id: FactoryToken, multiple: true })\r\nexport class SugarFactory implements Factory {\r\n\r\n    create() {\r\n        console.log(\"sugar created\");\r\n    }\r\n\r\n}\r\n\r\n// WaterFactory.ts\r\n@Service({ id: FactoryToken, multiple: true })\r\nexport class WaterFactory implements Factory {\r\n\r\n    create() {\r\n        console.log(\"water created\");\r\n    }\r\n\r\n}\r\n\r\n// app.ts\r\n// now you can get all factories in a single array \r\nconst factories = Container.getMany(FactoryToken); // factories is Factory[]\r\nfactories.forEach(factory => factory.create());\r\n``` \r\n\r\n### Using multiple containers and scoped containers\r\n\r\nBy default all services are stored in the global service container,\r\nand this global service container holds all unique instances of each service you have.\r\n\r\nIf you want your services to behave and store data inside differently,\r\nbased on some user context (http request for example) - \r\nyou can use different containers for different contexts. \r\nFor example:\r\n\r\n```javascript\r\n// QuestionController.ts\r\n@Service()\r\nexport class QuestionController {\r\n\r\n    constructor(protected questionRepository: QuestionRepository) {\r\n    }\r\n\r\n    save() {\r\n        this.questionRepository.save();\r\n    }\r\n}\r\n\r\n// QuestionRepository.ts\r\n@Service()\r\nexport class QuestionRepository {\r\n\r\n    save() {\r\n    }\r\n\r\n}\r\n\r\n// app.ts\r\nconst request1 = { param: \"question1\" };\r\nconst controller1 = Container.of(request1).get(QuestionController);\r\ncontroller1.save(\"Timber\");\r\nContainer.reset(request1);\r\n\r\nconst request2 = { param: \"question2\" };\r\nconst controller2 = Container.of(request2).get(QuestionController);\r\ncontroller2.save(\"\");\r\nContainer.reset(request2);\r\n```\r\n\r\nIn this example `controller1` and `controller2` are completely different instances,\r\nand `QuestionRepository` used in those controllers are different instances as well.\r\n\r\n`Container.reset` removes container with the given context identifier.\r\nIf you want your services to be completely global and not be container-specific, \r\nyou can mark them as global:\r\n\r\n```javascript\r\n@Service({ global: true })\r\nexport class QuestionUtils {\r\n  \r\n}\r\n```\r\n\r\nAnd this global service will be the same instance across all containers.\r\n\r\n### Remove registered services or reset container state\r\n\r\nIf you need to remove registered service from container simply use `Container.remove(...)` method.\r\nAlso you can completely reset the container by calling `Container.reset()` method.\r\nThis will effectively remove all registered services from the container.\r\n\r\n## Troubleshooting\r\n\r\n### Use TypeDI with routing-controllers and/or TypeORM\r\n\r\nIn order to use typedi with routing-controllers and/or typeorm, it's **necessary** to tell these libs to use the typedi container.\r\nOtherwise you may face [this kind of issue](https://github.com/pleerock/typedi/issues/4).\r\n\r\n```Typescript\r\nimport {useContainer as routingUseContainer} from \"routing-controllers\";\r\nimport {useContainer as ormUseContainer} from \"typeorm\";\r\nimport {Container} from \"typedi\";\r\n\r\nroutingUseContainer(Container);\r\normUseContainer(Container);\r\n```\r\n\r\n## Samples\r\n\r\nTake a look on samples in [./sample](https://github.com/pleerock/typedi/tree/master/sample) for examples of usage.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pleerock/typedi.git"
  },
  "scripts": {
    "test": "gulp tests"
  },
  "tags": [
    "di",
    "container",
    "di-container",
    "typescript",
    "typescript-di",
    "dependency-injection"
  ],
  "version": "0.7.2"
}
